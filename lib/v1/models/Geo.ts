/* tslint:disable */
/* eslint-disable */
/**
 * Opportify Insights API
 * ## Overview  The **Opportify Insights API** provides access to a powerful and up-to-date platform. With advanced data warehousing and AI-driven capabilities, this API is designed to empower your business to make informed, data-driven decisions and effectively assess potential risks.  ### Base URL Use the following base URL for all API requests:  ```plaintext https://api.opportify.ai/insights/v1/<service>/<endpoint> ```  ### Features - [**Email Insights:**](/docs/api/api-reference/email-insights)   - Validate email syntax.   - Identify email types (free, disposable, private or unknown).   - Real time verifications:     - Reachable: Confirms if the email domain has valid MX DNS records using DNS lookup.     - Deliverable: Simulates an SMTP handshake to check if the email address exists and is deliverable.     - Catch-All: Detects if the domain accepts all emails (catch-all configuration).   - Intelligent Error Correction: Automatically corrects well-known misspelled email addresses.   - Risk Report: Provides an AI-driven normalized score (200-1000) to evaluate email risk, using predefined thresholds.      [Access Documentation >>](/docs/api/api-reference/email-insights)  - [**IP Insights:**](/docs/api/api-reference/ip-insights)   - Connection types: Detects connection types such as `wired`, `mobile`, `enterprise`, `satellite`, `VPN`, `cloud-provider`, `open-proxy`, or `Tor`.   - Geo location: Delivers detailed insights such as country, city, timezone, language preferences, and additional location-based information to enhance regional understanding.   - WHOIS: Provides main details including RIR, ASN, organization, and abuse/admin/technical contacts.   - Trusted Provider Recognition: Identifies if the IP is part of a known trusted provider (e.g., ZTNA - Zero Trust Network Access).   - Blocklist Reports: Retrieves up-to-date blocklist statuses, active reports, and the latest detections.   - Risk Report: Delivers an AI-driven normalized score (200-1000) to evaluate IP risk, supported by predefined thresholds.    [Access Documentation >>](/docs/api/api-reference/ip-insights)  ### Authentication & Security - **API Key:** Access to the API requires an API key, which must be included in the request headers. Businesses can generate unlimited API keys directly from their account, offering flexibility and ease of use.  - **ACL Rules:** Enhance security with Access Control Lists (ACL), allowing you to restrict API access from specific IP addresses or ranges. This feature provides an additional layer of protection by ensuring only authorized IPs can interact with the API. - **No Query Parameters:** As a precautionary measure, our API avoids the use of query parameters for all operations, including authentication and handling Personally Identifiable Information (PII). This approach minimizes security risks by preventing sensitive data from being exposed in access logs, browser history, cached URLs, debugging tools, or inadvertently shared URLs. All sensitive information is securely transmitted through headers or the request body. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
/**
 * ### Geolocation Determination & Confidence Levels
 * Geolocation details are derived by analyzing the provided IP address using data aggregated from a wide range of sources, both official and unofficial (such as user-generated data, open-source, or crowdsourced). This data is meticulously evaluated and ranked using a proprietary weighted reliability score that is tailored to the specific characteristics and trustworthiness of each data source.
 * 
 * ---
 * 
 * #### Confidence Levels
 * 
 * The geolocation process assigns a confidence level to each level of granularity. These levels reflect the probability of accuracy based on the reliability of the data and analysis:
 * 
 * - **Continent-Level (99%)**: The determination of the continent is highly reliable, with a near-certain accuracy rate of 99%.
 * - **Country-Level (98%)**: Locating the specific country has a very high accuracy of 98%, reflecting reliable cross-verification.
 * - **Region-Level (70–90%)**: Identifying regions (such as states or provinces) has moderate to high accuracy, depending on the data quality and density for the given area.
 * - **City-Level (50–70%)**: Pinpointing the specific city is moderately accurate, influenced by factors such as ISP data resolution and urban vs. rural settings.
 * - **Specific Area/Point (5–40%)**: Pinpointing a highly specific area (e.g., a neighborhood or street) has a significantly lower confidence level due to inherent limitations in IP-based geolocation technology.
 * 
 * ---
 * 
 * #### Key Features
 * 
 * - **Alphabetical Object Sorting**:  
 *   The keys in the returned geolocation object are consistently sorted alphabetically, ensuring a predictable structure for easier integration and parsing.
 * 
 * ---
 * 
 * ### Response Elements
 * 
 * @export
 * @interface Geo
 */
export interface Geo {
    /**
     * Name of the continent. Normalized as "Title Case".
     * @type {string}
     * @memberof Geo
     */
    continent?: string;
    /**
     * ISO 3166-1 alpha-2 country code.
     * @type {string}
     * @memberof Geo
     */
    countryCode?: string;
    /**
     * Full name of the country. Normalized as "Title Case".
     * @type {string}
     * @memberof Geo
     */
    countryName?: string;
    /**
     * ISO 3166-1 English short version. Normalized as "Title Case".
     * @type {string}
     * @memberof Geo
     */
    countryShortName?: string;
    /**
     * Name of the city. Normalized as "Title Case".
     * @type {string}
     * @memberof Geo
     */
    city?: string;
    /**
     * ISO 4217 currency code.
     * @type {string}
     * @memberof Geo
     */
    currencyCode?: string;
    /**
     * Top-level domain (TLD) for the country. 63 characters limit. IANA / ICANN defined.
     * @type {string}
     * @memberof Geo
     */
    domainExtension?: string;
    /**
     * List of languages spoken in the country separated by commas. (BCP 47 (Best Current Practice 47))
     * @type {string}
     * @memberof Geo
     */
    languages?: string;
    /**
     * Latitude coordinate.
     * @type {number}
     * @memberof Geo
     */
    latitude?: number;
    /**
     * Longitude coordinate.
     * @type {number}
     * @memberof Geo
     */
    longitude?: number;
    /**
     * Postal code. Normalized to all capital letters when applicable.
     * @type {string}
     * @memberof Geo
     */
    postalCode?: string;
    /**
     * International dialing code.
     * @type {string}
     * @memberof Geo
     */
    phoneIntCode?: string;
    /**
     * Name of the region, province, or state. Normalized as "Title Case".
     * @type {string}
     * @memberof Geo
     */
    region?: string;
    /**
     * Timezone in IANA format.
     * @type {string}
     * @memberof Geo
     */
    timezone?: string;
}

/**
 * Check if a given object implements the Geo interface.
 */
export function instanceOfGeo(value: object): value is Geo {
    return true;
}

export function GeoFromJSON(json: any): Geo {
    return GeoFromJSONTyped(json, false);
}

export function GeoFromJSONTyped(json: any, ignoreDiscriminator: boolean): Geo {
    if (json == null) {
        return json;
    }
    return {
        
        'continent': json['continent'] == null ? undefined : json['continent'],
        'countryCode': json['countryCode'] == null ? undefined : json['countryCode'],
        'countryName': json['countryName'] == null ? undefined : json['countryName'],
        'countryShortName': json['countryShortName'] == null ? undefined : json['countryShortName'],
        'city': json['city'] == null ? undefined : json['city'],
        'currencyCode': json['currencyCode'] == null ? undefined : json['currencyCode'],
        'domainExtension': json['domainExtension'] == null ? undefined : json['domainExtension'],
        'languages': json['languages'] == null ? undefined : json['languages'],
        'latitude': json['latitude'] == null ? undefined : json['latitude'],
        'longitude': json['longitude'] == null ? undefined : json['longitude'],
        'postalCode': json['postalCode'] == null ? undefined : json['postalCode'],
        'phoneIntCode': json['phoneIntCode'] == null ? undefined : json['phoneIntCode'],
        'region': json['region'] == null ? undefined : json['region'],
        'timezone': json['timezone'] == null ? undefined : json['timezone'],
    };
}

export function GeoToJSON(json: any): Geo {
    return GeoToJSONTyped(json, false);
}

export function GeoToJSONTyped(value?: Geo | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'continent': value['continent'],
        'countryCode': value['countryCode'],
        'countryName': value['countryName'],
        'countryShortName': value['countryShortName'],
        'city': value['city'],
        'currencyCode': value['currencyCode'],
        'domainExtension': value['domainExtension'],
        'languages': value['languages'],
        'latitude': value['latitude'],
        'longitude': value['longitude'],
        'postalCode': value['postalCode'],
        'phoneIntCode': value['phoneIntCode'],
        'region': value['region'],
        'timezone': value['timezone'],
    };
}

